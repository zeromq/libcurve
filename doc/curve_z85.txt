curve_z85(3)
============

NAME
----
curve_z85 - Z85 encoding and decoding, see 0MQ RFC 32

SYNOPSIS
--------
----
//  Encode a binary frame as a string; destination string MUST be at least
//  size * 5 / 4 bytes long. Returns dest. Size must be a multiple of 4.
CZMQ_EXPORT char *
    curve_z85_encode (char *dest, uint8_t *data, size_t size);
    
//  Decode an encoded string into a binary frame; dest must be at least
//  strlen (string) * 4 / 5 bytes long. Returns dest. strlen (string) 
//  must be a multiple of 5.
CZMQ_EXPORT uint8_t *
    curve_z85_decode (uint8_t *dest, char *string);
    
//  Self test of this class
void
    curve_z85_test (bool verbose);
----

DESCRIPTION
-----------

Provides an API to encode and decode CurveZMQ keys to/from Z85, 
a text format designed for easier interchange.

Please add @discuss section in ../src/curve_z85.c.

EXAMPLE
-------
.From curve_z85_test method
----
byte test_data_1 [8] = {
    0x86, 0x4F, 0xD2, 0x6F, 0xB5, 0x59, 0xF7, 0x5B
};
byte test_data_2 [32] = {
    0x8E, 0x0B, 0xDD, 0x69, 0x76, 0x28, 0xB9, 0x1D, 
    0x8F, 0x24, 0x55, 0x87, 0xEE, 0x95, 0xC5, 0xB0, 
    0x4D, 0x48, 0x96, 0x3F, 0x79, 0x25, 0x98, 0x77, 
    0xB4, 0x9C, 0xD9, 0x06, 0x3A, 0xEA, 0xD3, 0xB7  
};
char encoded [40];
byte decoded [32];

curve_z85_encode (encoded, NULL, 0);
assert (streq (encoded, ""));
curve_z85_decode (decoded, encoded);

curve_z85_encode (encoded, test_data_1, 8);
assert (strlen (encoded) == 10);
assert (streq (encoded, "HelloWorld"));
curve_z85_decode (decoded, encoded);
assert (memcmp (test_data_1, decoded, 8) == 0);

curve_z85_encode (encoded, test_data_2, 32);
assert (strlen (encoded) == 40);
assert (streq (encoded, "JTKVSB%%)wK0E.X)V>+}o?pNmC{O&4W4b!Ni{Lh6"));
curve_z85_decode (decoded, encoded);
assert (memcmp (test_data_2, decoded, 32) == 0);

//  Standard test keys defined by zmq_curve man page
byte client_public [32] = { 
    0xBB, 0x88, 0x47, 0x1D, 0x65, 0xE2, 0x65, 0x9B, 
    0x30, 0xC5, 0x5A, 0x53, 0x21, 0xCE, 0xBB, 0x5A, 
    0xAB, 0x2B, 0x70, 0xA3, 0x98, 0x64, 0x5C, 0x26, 
    0xDC, 0xA2, 0xB2, 0xFC, 0xB4, 0x3F, 0xC5, 0x18
};
byte client_secret [32] = { 
    0x7B, 0xB8, 0x64, 0xB4, 0x89, 0xAF, 0xA3, 0x67, 
    0x1F, 0xBE, 0x69, 0x10, 0x1F, 0x94, 0xB3, 0x89, 
    0x72, 0xF2, 0x48, 0x16, 0xDF, 0xB0, 0x1B, 0x51, 
    0x65, 0x6B, 0x3F, 0xEC, 0x8D, 0xFD, 0x08, 0x88
};
curve_z85_encode (encoded, client_public, 32);
curve_z85_encode (encoded, client_secret, 32);

byte server_public [32] = { 
    0x54, 0xFC, 0xBA, 0x24, 0xE9, 0x32, 0x49, 0x96, 
    0x93, 0x16, 0xFB, 0x61, 0x7C, 0x87, 0x2B, 0xB0, 
    0xC1, 0xD1, 0xFF, 0x14, 0x80, 0x04, 0x27, 0xC5, 
    0x94, 0xCB, 0xFA, 0xCF, 0x1B, 0xC2, 0xD6, 0x52
};
byte server_secret [32] = { 
    0x8E, 0x0B, 0xDD, 0x69, 0x76, 0x28, 0xB9, 0x1D, 
    0x8F, 0x24, 0x55, 0x87, 0xEE, 0x95, 0xC5, 0xB0, 
    0x4D, 0x48, 0x96, 0x3F, 0x79, 0x25, 0x98, 0x77, 
    0xB4, 0x9C, 0xD9, 0x06, 0x3A, 0xEA, 0xD3, 0xB7
};
curve_z85_encode (encoded, server_public, 32);
curve_z85_encode (encoded, server_secret, 32);
----
